% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zTest.R
\name{generateZTestData}
\alias{generateZTestData}
\title{Simulate function for a safeZDesign object}
\usage{
generateZTestData(
  n1Plan,
  n2Plan = NULL,
  nsim = 1000L,
  deltaTrue = 0,
  muGlobal = 0,
  sigmaTrue = 1,
  paired = FALSE,
  seed = NULL
)
}
\arguments{
\item{n1Plan}{integer, that defines the maximum number of samples to plan for (according to the safe test,
use designSafeT to find this)}

\item{n2Plan}{optional integer, that defines the maximum number of samples of the second group to plan for}

\item{nsim}{numeric, number of iterations}

\item{deltaTrue}{numeric, if NULL, then deltaTrue <- object[["deltaMin"]]}

\item{muGlobal}{numeric, the true global mean of a paired or two-sample t-test. Its value shouldn't matter for the
test. This parameter treated is treated as a nuisance.}

\item{sigmaTrue}{numeric > 0,the true standard deviation of the data. Its value shouldn't matter for the test.
This parameter treated is treated as a nuisance.}

\item{paired}{logical, true if the simulated data are paired.}

\item{seed}{numeric, seed number}

\item{object}{A safeZDesign object}
}
\value{
a safeZSim object

a list of two data matrices
}
\description{
Simulate function for a safeZDesign object
}
\examples{
# Design safe test
alpha <- 0.05
beta <- 0.20
deltaMin <- 1
designObj <- designSafeZ(deltaMin, alpha=alpha, beta=beta)

# Design frequentist test
freqObj <- designFreqT(deltaMin, alpha=alpha, beta=beta)

# Simulate based on deltaTrue=deltaMin
simResultsDeltaTrueIsDeltaMin <- simulate(object=designObj, nsim=100)

# Simulate based on deltaTrue > deltaMin
simResultsDeltaTrueIsLargerThanDeltaMin <- simulate(
  object=designObj, nsim=100, deltaTrue=2)

# Simulate under the null deltaTrue = 0
simResultsDeltaTrueIsNull <- simulate(
  object=designObj, nsim=100, deltaTrue=0)

simulate(object=designObj, deltraTrue=0, nsim=100, freqOptioStop=TRUE,
         n1PlanFreq=freqObj$n1PlanFreq, n2PlanFreq=freqObj$n2PlanFreq)

simulate.safeZDesign <- function(object, nsim=1, seed=NULL, deltaTrue=NULL, muGlobal=0, sigmaTrue=1, lowN=3,
                                 safeOptioStop=TRUE, freqOptioStop=FALSE, n1PlanFreq=NULL, n2PlanFreq=NULL,
                                 logging=TRUE, pb=TRUE, ...) {

  # LATER

  if (object[["pilot"]])
    stop("No simulation for unplanned pilot designs")

  if (is.null(deltaTrue)) {
    deltaTrue <- object[["deltaMin"]]
  }

  if (object[["testType"]]=="pairedSampleT") {
    paired <- TRUE
  } else {
    paired <- FALSE
  }

  result <- replicateTTests("n1Plan"=object[["n1Plan"]], "n2Plan"=object[["n2Plan"]], "deltaTrue"=deltaTrue,
                            "muGlobal"=muGlobal, "sigmaTrue"=sigmaTrue, "paired"=paired,
                            "alternative"=object[["alternative"]], "lowN"=lowN, "nsim"=nsim, "alpha"=object[["alpha"]],
                            "safeOptioStop"=safeOptioStop, "deltaS"=object[["deltaS"]],
                            "freqOptioStop"=freqOptioStop, "n1PlanFreq"=n1PlanFreq, "n2PlanFreq"=n2PlanFreq,
                            "logging"=logging, "seed"=seed, "pb"=pb, ...)

  object <- utils::modifyList(object, result)
  class(object) <- "safeZSim"
  return(object)
}

#' Prints a safeZSim object
#'
#' @param x a safeZSim object
#' @param ... further arguments to be passed to or from methods.
#'
#' @export
#'
#' @examples
#' designObj <- designSafeZ(1)
#'
#' # Data under deltaTrue=deltaMin
#' simObj <- simulate(designObj, nsim=100)
#' simObj
#'
#' # Data under the null deltaTrue=0
#' simObj <- simulate(designObj, nsim=100, deltaTrue=0, freqOptioStop=TRUE, n1PlanFreq=10)
#' simObj
print.safeZSim <- function(x, ...) {
  analysisName <- getNameTestType(testType = x[["testType"]])

  if(!is.null(x[["safeSim"]])) {
    cat("\n")
    cat("   Simulations for", analysisName, "\n")
    cat("\n")
  }

  cat("Based on nsim =", x[["nsim"]], "and ")

  cat("if the true effect size is \n")
  cat("    deltaTrue =", x[["deltaTrue"]])
  cat("\n")

  cat("then the safe test optimised to detect an effect size of at least: \n")
  cat("    deltaMin =", x[["deltaMin"]]) # TODO(Alexander): deltaMin phiMin
  cat("\n")
  cat("with tolerable type I error rate of ")
  cat("\n")
  cat("    alpha =", x[["alpha"]], "and power: 1-beta =", 1-x[["beta"]])
  cat("\n")
  if (is.null(x[["n2Plan"]])) {
    cat("for experiments with planned sample size: \n")
    cat("    n1Plan =", x[["n1Plan"]])
  } else {
    cat("For experiments with planned sample sizes: \n")
    cat("    n1Plan =", x[["n1Plan"]], "and n2Plan =", x[["n2Plan"]])
  }
  cat("\n")

  cat("\n")
  cat("Is estimated to have a null rejection rate of")
  cat("\n")
  cat("    powerAtNPlan =", x[["safeSim"]][["powerAtN1Plan"]])
  cat("\n")
  cat("at the planned sample sizes.")
  cat("\n")
  freqPowerAtN1Plan <- x[["freqSim"]][["powerAtN1Plan"]]
  if (!is.null(freqPowerAtN1Plan)) {
    cat("For the p-value test:    freqPowerAtNPlan =", freqPowerAtN1Plan)
    cat("\n")
  }
  cat("\n")

  cat("Is estimated to have a null rejection rate of ")
  cat("\n")
  cat("    powerOptioStop =", x[["safeSim"]][["powerOptioStop"]])
  cat("\n")
  cat("under optional stopping, and the average stopping time is:")
  cat("\n")

  if (is.null(x[["n2Plan"]])) {
    cat("    n1Mean =", x[["safeSim"]][["nMean"]])
  } else {
    cat("    n1Mean =", x[["safeSim"]][["nMean"]], "and n2Mean =", x[["sampleSizeRatio"]]*x[["safeSim"]][["nMean"]])
  }
  cat("\n")

  freqPowerOptioStop <- x[["freqSim"]][["powerOptioStop"]]
  if (!is.null(freqPowerAtN1Plan)) {
    cat("For the p-value test:    freqPowerOptioStop =", freqPowerOptioStop)
    cat("\n")
  }
}

#' Plots a safeZSim object
#'
#' @inheritParams plotHistogramDistributionStoppingTimes
#' @param x A safeZDesign object
#' @param y NULL
#' @param ... further arguments to be passed to or from methods.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'# Design safe test
#' alpha <- 0.05
#' beta <- 0.20
#' designObj <- designSafeZ(1, alpha=alpha, beta=beta)
#'
#' # Design frequentist test
#' freqObj <- designFreqT(1, alpha=alpha, beta=beta)
#'
#' # Simulate under the alternative with deltaTrue=deltaMin
#' simResults <- simulate(designObj, nsim=100)
#'
#' plot(simResults)
#'
#' plot(simResults, showOnlyNRejected=TRUE)
#' }
#'
plot.safeZSim <- function(x, y=NULL, showOnlyNRejected=FALSE, nBin=25, ...) {
  plotHistogramDistributionStoppingTimes(x[["safeSim"]],
                                         "nPlan" = x[["n1Plan"]],
                                         "deltaTrue" = x[["deltaTrue"]],
                                         "showOnlyNRejected" = showOnlyNRejected, "nBin"=nBin)
}




#' Plots the sample sizes necessary for a tolerable alpha and beta as a function of deltaMin
#'
#' For given tolerable alpha and beta, as a function of the minimal clinical relevant effect size deltaMin, plots (1) the
#' sample sizes to plan for for a safe test (2) the frequentist test, (3) the average sample size necessary due to
#' optional stopping.
#'
#' @inheritParams designSafeZ
#' @inheritParams replicateTTests
#' @param maxN numeric, the maximum number of samples one has budget for to collect data
#' @param deltaFactor numeric, a factor to robustify the sequential determination (e.g., from deltaTrue = 0.9, to
#' deltaTrue = 0.8) of lowDelta
#' @param nFactor numeric, a factor to robustify the sequential determination (e.g., from deltaTrue = 0.9, to
#' deltaTrue = 0.8) of highN
#' @param simulateSafeOptioStop logical, if TRUE then provides
#' @param logging logical, if TRUE then output all the safe designs objects including mean n stop if
#' simulateSafeOptioStop==TRUE
#' @param backTest logical, if TRUE it provides the frequentist sample size necessary to attain the power that the
#' safe test attains due to optional stopping
#' @param freqPlot logical, if TRUE plot frequentist sample size profiles

#'
#' @return Plot of the sample size profiles for tolerable type I and type II error, also outputs results object
#' @export
#'
#' @examples
#' plotSafeZDesignSampleSizeProfile()
plotSafeZDesignSampleSizeProfile <- function(alpha=0.05, beta=0.2, maxN=200, lowDelta=0.01, highDelta=1, tol=0.1,
                                             testType=c("oneSampleT", "pairedSampleT", "twoSampleT"), nsim=1000L,
                                             alternative=c("two.sided", "greater", "less"), sampleSizeRatio=1,
                                             deltaFactor=0.5, nFactor=2, simulateSafeOptioStop=FALSE,
                                             logging=FALSE, backTest=FALSE, seed=NULL, freqPlot=FALSE, pb=TRUE,
                                             ...) {

  stopifnot(lowDelta < highDelta, alpha > 0, beta > 0, alpha < 1, beta < 1)

  # Order from high to low
  deltaDomain <- -seq(-highDelta, -lowDelta, by=tol)
  testType <- match.arg(testType)

  result <- list("alpha"=alpha, "beta"=beta, "maxN"=maxN, "deltaDomain"=deltaDomain)

  lastDeltaIndex <- length(deltaDomain)

  if (lastDeltaIndex < 1)
    stop("Either maxN or deltaDomain is too small. Please lower lowDelta or make highDelta larger")


  if (testType=="pairedSampleT") {
    paired <- TRUE
  } else {
    paired <- FALSE
  }

  allN1PlanFreq <- vector("integer", lastDeltaIndex)


  # 1. Freq design  ---------------------------------------------------------------------
  freqDesign <- list("n1PlanFreq"=3)

  for (i in seq.int(lastDeltaIndex)) {
    if (i==1) {
      tempLowN <- 3
    } else {
      # Note(Alexander): Use previous found n1
      # TODO(Alexander): Show that as deltaMin decreases that n1PlanFreq increases
      tempLowN <- freqDesign[["n1PlanFreq"]]
    }

    freqDesign <- designFreqT("deltaMin"=deltaDomain[i], "alpha"=alpha, "beta"=beta, "lowN"=tempLowN,
                              "highN"=maxN, "sampleSizeRatio"=sampleSizeRatio)

    if (is.null(freqDesign[["n1PlanFreq"]]) || is.na(freqDesign[["n1PlanFreq"]])) {
      lastDeltaIndex <- i-1

      # Note(Alexander): Prune
      allN1PlanFreq <- allN1PlanFreq[1:lastDeltaIndex]
      break()
    }

    allN1PlanFreq[i] <- freqDesign[["n1PlanFreq"]]
  }


  # #### 1.a. Plots freq
  # graphics::plot(deltaDomain[seq.int(lastDeltaIndex)], allN1PlanFreq[seq.int(lastDeltaIndex)],
  #                lty=3, lwd=2, type="l", col="darkgrey", ylab="n1", xlab=expression(delta["min"]))
  #
  # abline(h=maxN, col="red", lty=2)
  #
  # legend("topright", legend = c("Freq design", "max n"),
  #        col = c("darkgrey", "red"),
  #        lty = c(3, 2), bty="n")

  # 2. Safe design  ---------------------------------------------------------------------
  #
  allDeltaS <- allN1PlanSafe <- vector("integer", lastDeltaIndex)
  allSafeDesignObj <- vector("list", lastDeltaIndex)

  # TODO(Alexander): Show that for fixed theta that freqN < safeN,
  # TODO(Alexander): Instead, of doing this based on the previous one (deltaMin), try to be faster
  # by going around a guessed quantity based on a factor of safeDesignObj$n/freqDesign$n
  #
  # TODO(Alexander): Show that due to monotonicity that we can take "highDelta"=deltaDomain[i-1]
  for (i in seq.int(lastDeltaIndex)) {
    if (i==1) {
      tempLowDelta <- lowDelta
      tempHighDelta <- highDelta
      tempLowN <- 3
      tempHighN <- maxN
    } else {
      # Note(Alexander): Use previous found deltaS times a correction factor as a lowerbound for the search space of
      # deltaS
      tempLowDelta <- deltaFactor*safeDesignObj[["deltaS"]]/deltaDomain[i-1]*deltaDomain[i]

      # Note(Alexander): Use previous true deltaMin > previous deltaS as an upper bound
      # TODO(Alexander): Show that as deltaMin decreases that deltaS dereases
      tempHighDelta <- deltaDomain[i-1]

      # Note(Alexander): Use previously found design
      # TODO(Alexander): Show that as deltaMin decreases that n1Plan increases
      tempLowN <- safeDesignObj[["n1Plan"]]

      # Note(Alexander): Use previously found n1Plan times a factor as an upper bound
      # TODO(Alexander): Show that as deltaMin decreases that n1Plan increases
      tempHighN <- ceiling(nFactor * safeDesignObj[["n1Plan"]]/allN1PlanFreq[i-1]*allN1PlanFreq[i])
    }

    safeDesignObj <- designSafeZ("deltaMin"=deltaDomain[i], "alpha"=alpha, "beta"=beta, "alternative"=alternative,
                                 "lowDelta"=tempLowDelta, "highDelta"=tempHighDelta, "lowN"=tempLowN,
                                 "highN"=tempHighN, "testType"=testType, "sampleSizeRatio"=sampleSizeRatio)

    if (is.null(safeDesignObj[["n1Plan"]]) || is.na(safeDesignObj[["n1Plan"]])) {
      lastDeltaIndex <- i-1
      break()
    }

    # TODO(Alexander): Not necessary anymore, with normal function call
    safeDesignObj[["n1PlanFreq"]] <- allN1PlanFreq[i]
    allSafeDesignObj[[i]] <- safeDesignObj
    allN1PlanSafe[i] <- safeDesignObj[["n1Plan"]]
    allDeltaS[i] <- safeDesignObj[["deltaS"]]
  }

  deltaDomain <- deltaDomain[1:lastDeltaIndex]
  allDeltaS <- allDeltaS[1:lastDeltaIndex]

  # TODO(Alexander) Optional?
  # graphics::plot(deltaDomain, allDeltaS)


  maxDeltaDomain <- max(deltaDomain)
  minDeltaDomain <- min(deltaDomain)


  # Store in output
  result[["deltaDomain"]] <- deltaDomain
  result[["allN1PlanFreq"]] <- allN1PlanFreq
  result[["allN1PlanSafe"]] <- allN1PlanSafe
  result[["allDeltaS"]] <- allDeltaS

  # 2.a. Plot Safe -----
  setSafeStatsPlotOptions()
  graphics::plot(deltaDomain, allN1PlanSafe, type="l", col="blue", lty=1, lwd=2, xlim=c(minDeltaDomain, maxDeltaDomain),
                 ylab="n1", xlab=expression(delta["min"]),
                 main=bquote(~alpha == ~.(alpha) ~ "and" ~beta== ~.(beta)))

  if (freqPlot) {
    graphics::lines(deltaDomain, allN1PlanFreq, col="darkgrey", lwd=2, lty=3)
    legendName <- c("Safe design", "Freq design", "max n")
    legendCol <- c("blue", "darkgrey", "red")
    legendLty <- c(1, 3, 2)
  } else {
    legendName <- c("Safe design", "max n")
    legendCol <- c("blue", "red")
    legendLty <- c(1, 2)
  }

  graphics::abline(h=maxN, col="red", lty=2)

  graphics::legend("topright", legend = legendName,
                   col = legendCol, lty = legendLty, bty="n")

  # 3. Run simulations  ---------------------------------------------------------------------
  #
  if (simulateSafeOptioStop) {
    allNMean <- allProbLeqNFreq <- vector("integer", lastDeltaIndex)

    if (backTest)
      allNBack <- vector("integer", lastDeltaIndex)

    if (pb)
      pbOptioStop <- utils::txtProgressBar("style"=1)

    for (i in seq.int(lastDeltaIndex)) {
      safeDesignObj <- allSafeDesignObj[[i]]

      if (i==1) {
        tempLowN <- 3
      } else {
        # Note(Alexander): Use for lowN the smallest N found in the previous simulations
        tempLowN <- simObj[["safeSim"]][["lowN"]]
      }

      simObj <- replicateTTests("n1Plan"=safeDesignObj[["n1Plan"]], "n2Plan"=safeDesignObj[["n2Plan"]],
                                "deltaTrue"=deltaDomain[i], "paired"=paired, "alternative"=alternative,
                                "lowN"=tempLowN, "alpha"=alpha, "deltaS"=safeDesignObj[["deltaS"]],
                                "n1PlanFreq"=allN1PlanFreq[i], "pb"=FALSE, "nsim"=nsim)
      allNMean[i] <- simObj[["safeSim"]][["nMean"]]
      allProbLeqNFreq[i] <- simObj[["safeSim"]][["probLeqN1PlanFreq"]]

      if (backTest) {
        backFreqDesign <- designFreqT("deltaMin"=deltaDomain[i], "alpha"=alpha,
                                      "beta"=1-safeDesign[["safeSim"]][["powerOptioStop"]],
                                      "alternative"=alternative, "testType"=testType,
                                      "sampleSizeRatio"=sampleSizeRatio)

        safeDesign[["safeSim"]][["nBack"]] <- backFreqDesign[["n1PlanFreq"]]
        allNBack[i] <- backFreqDesign[["n1PlanFreq"]]
      } # End back test

      safeDesignObj <- utils::modifyList(safeDesignObj, simObj)
      allSafeDesignObj[[i]] <- safeDesignObj

      if (pb)
        utils::setTxtProgressBar("pb"=pbOptioStop, "value"=i/lastDeltaIndex)

    } # End looping over deltaDomain as deltaTrue

    if (pb)
      close(pbOptioStop)

    result[["allNMean"]] <- allNMean
    result[["allProbLeqNFreq"]] <- allProbLeqNFreq

    if (backTest)
      result[["allNBack"]] <- allNBack

    # 3.a. Plot Sim  -----
    setSafeStatsPlotOptions()

    graphics::plot(deltaDomain, allN1PlanSafe, type="l", col="blue", lty=2, lwd=2, xlim=c(minDeltaDomain, maxDeltaDomain),
                   ylab="n1", xlab=expression(delta["min"]),
                   main=bquote(~alpha == ~.(alpha) ~ "and" ~beta== ~.(beta)))
    graphics::abline(h=maxN, col="red", lty=2)
    graphics::lines(deltaDomain, allNMean, col="black", lwd=2, lty=1)

    if (freqPlot) {
      graphics::lines(deltaDomain, allN1PlanFreq, col="darkgrey", lwd=2, lty=3)
      legendName <- c("Average n", "Safe design", "Freq design", "max n")
      legendCol <- c("black", "blue", "darkgrey", "red")
      legendLty <- c(1, 2, 3, 2)
    } else {
      legendName <- c("Average n", "Safe design", "max n")
      legendCol <- c("black", "blue", "red")
      legendLty <- c(1, 2, 2)
    }

    graphics::legend("topright", legend = legendName, col = legendCol, lty=legendLty, bty="n")
  }

  if (logging)
    result[["allSafeDesignObj"]] <- allSafeDesignObj

  return(result)
}



#' Simulate multiple data sets to show the effects of optional testing for safe (and frequentist) tests.
#'
#' @param n1Plan integer, that defines the maximum number of samples to plan for (according to the safe test,
#' use designSafeZ to find this)
#' @param n2Plan optional integer, that defines the maximum number of samples of the second group to plan for
#' @param deltaTrue numeric, the value of the true effect size (test-relevant parameter)
#' @param muGlobal numeric, the true global mean of a paired or two-sample t-test. Its value shouldn't matter for the
#' test. This parameter treated is treated as a nuisance.
#' @param sigmaTrue numeric > 0,the true standard deviation of the data. Its value shouldn't matter for the test.
#' This parameter treated is treated as a nuisance.
#' @param paired logical, true if the simulated data are paired.
#' @param alternative a character string specifying the alternative hypothesis must be one of "two.sided" (default),
#' "greater" or "less"
#' @param lowN the smallest number of samples (first group) at which monitoring of the tests begins
#' @param nsim the number of replications, that is, experiments with max samples n1Plan and n2Plan
#' @param alpha the tolerable type I error to be conserved. Also defines the decision rule s > 1/alpha, and for
#' frequentist tests the decision rule is p < alpha.
#' @param safeOptioStop logical, TRUE implies that optional stopping simulation is performed for the safe test
#' @param deltaS numeric, the safe test defining deltaS (use designSafeZ to find this)
#' @param freqOptioStop logical, TRUE implies that optional stopping simulation is performed for the frequentist test
#' @param n1PlanFreq integer, that defines the maximum number of samples to plan for (according to the frequentist
#' test,use designFreqT to find this)
#' @param n2PlanFreq optional integer, that defines the maximum number of samples of the second group to plan for
#' @param seed To set the seed for the simulated data
#' @param logging logical, if TRUE, then return the simulated data
#' @param pb logical, if TRUE, then show progress bar
#' @param ... further arguments to be passed to or from methods.
#'
#' @return Returns a safeSim object.
#' @export
#'
#' @examples
#'
#'# Design safe test
#' alpha <- 0.05
#' beta <- 0.20
#' designObj <- designSafeZ(1, alpha=alpha, beta=beta)
#'
#' # Design frequentist test
#' freqObj <- designFreqT(1, alpha=alpha, beta=beta)
#'
#' # Simulate under the alternative with deltaTrue=deltaMin
#' simResults <- replicateTTests(n1Plan=designObj$n1Plan, deltaTrue=1, deltaS=designObj$deltaS,
#' n1PlanFreq=freqObj$n1PlanFreq, nsim=400)
#'
#' # Should be about 1-beta
#' simResults$safeSim$powerAtN1Plan
#'
#' # This is higher due to optional stopping
#' simResults$safeSim$powerOptioStop
#'
#' # Optional stopping allows us to do better than n1PlanFreq once in a while
#' simResults$safeSim$probLeqN1PlanFreq
#' graphics::hist(simResults$safeSim$allN, main="Histogram of stopping times", xlab="n1",
#' breaks=seq.int(designObj$n1Plan))
#'
#' # Simulate under the alternative with deltaTrue > deltaMin
#' simResults <- replicateTTests(n1Plan=designObj$n1Plan, deltaTrue=1.5, deltaS=designObj$deltaS,
#' n1PlanFreq=freqObj$n1PlanFreq, nsim=400)
#'
#' # Should be larger than 1-beta
#' simResults$safeSim$powerAtN1Plan
#'
#' # This is even higher due to optional stopping
#' simResults$safeSim$powerOptioStop
#'
#' # Optional stopping allows us to do better than n1PlanFreq once in a while
#' simResults$safeSim$probLeqN1PlanFreq
#' graphics::hist(simResults$safeSim$allN, main="Histogram of stopping times", xlab="n1",
#' breaks=seq.int(designObj$n1Plan))
#'
#' # Under the null deltaTrue=0
#' simResults <- replicateTTests(n1Plan=designObj$n1Plan, deltaTrue=0, deltaS=designObj$deltaS,
#' n1PlanFreq=freqObj$n1PlanFreq, freqOptioStop=TRUE, nsim=400)
#'
#'# Should be lower than alpha, because if the null is true, P(S > 1/alpha) < alpha for all n
#' simResults$safeSim$powerAtN1Plan
#'
#' # This is a bit higher due to optional stopping, but if the null is true,
#' # then still P(S > 1/alpha) < alpha for all n
#' simResults$safeSim$powerOptioStop
#'
#' # Should be lowr than alpha, as the experiment is performed as was planned
#' simResults$freqSim$powerAtN1Plan
#'
#' # This is larger than alpha, due to optional stopping.
#' simResults$freqSim$powerOptioStop
#' simResults$freqSim$powerOptioStop > alpha
replicateZTests <- function(n1Plan, n2Plan=NULL, deltaTrue, muGlobal=0, sigmaTrue=1, paired=FALSE,
                            alternative=c("two.sided", "greater", "less"), lowN=3,
                            nsim=1000L, alpha=0.05,
                            safeOptioStop=TRUE, deltaS=NULL,
                            freqOptioStop=FALSE, n1PlanFreq=NULL, n2PlanFreq=NULL,
                            logging=TRUE, seed=NULL, pb=TRUE, ...) {
  stopifnot(n1Plan > 0, n1Plan > lowN, nsim > 0, alpha > 0, alpha < 1,
            any(safeOptioStop, freqOptioStop))

  alternative <- match.arg(alternative)

  result <- list(n1Plan=n1Plan, n2Plan=n2Plan, deltaTrue=deltaTrue, muGlobal=muGlobal, paired=paired,
                 alternative=alternative, lowN=lowN, nsim=nsim, alpha=alpha,
                 deltaS=deltaS, n1PlanFreq=n1PlanFreq, n2PlanFreq=n2PlanFreq, safeSim=list(), freqSim=list())
  class(result) <- "safeZSim"

  if (safeOptioStop) {
    if (is.null(deltaS)) {
      stop(paste("To simulate safe t-tests results under optional stopping, this function 'replicateTTests' requires",
                 "the specification of the safe test with a deltaS. This deltaS can be found by running",
                 "the 'designSafeZ' function")
      )
    }

    if (paired && n1Plan != n2Plan)
      stop("For a paired t-test n2Plan needs to equal n1Plan")

    safeSim <- list(powerOptioStop=NA, powerAtN1Plan=NA, nMean=NA, probLeqN1PlanFreq=NA, probLessNDesign=NA, lowN=NA)

    allSafeN <- rep(n1Plan, times=nsim)
    sValues <- safeDecisionAtN <- allSafeDecisions <- vector("integer", nsim)
  }

  if (freqOptioStop) {
    if (!safeOptioStop) {
      if (is.null(n1Plan)) {
        warning("No n1PlanFreq specified, use n1Plan instead.")
        n1PlanFreq <- n1Plan
        n2PlanFreq <- n2Plan
      }
    }

    # Note(Alexander): This means that n1Plan and n2Plan refer to the planned samples of the safe tests

    if (is.null(n1PlanFreq)) {
      stop(paste("To simulate frequentist t-tests results under optional stopping, this",
                 "function 'replicateTTests' requires the specification of n1PlanFreq. To figure out how many",
                 "samples one requires in a frequentist test, please run the 'designFreqT' function.")
      )
    }


    if (!is.null(n2Plan) && is.null(n2PlanFreq)) {
      stop(paste("To simulate a two-sample frequentist t-tests results under optional stopping, this",
                 "function 'replicateTTests' requires the specification of n1PlanFreq. To figure out how many ",
                 "samples one requires in a frequentist test, please run the 'designFreqT' function.")
      )
    }

    if (paired && n1PlanFreq != n2PlanFreq)
      stop("For a paired t-test n2PlanFreq needs to equal n1PlanFreq")

    freqSim <- list(powerOptioStop=NA, powerAtN1Plan=NA, nMean=NA, probLessNDesign=NA, lowN=NA)

    allFreqN <- rep(n1PlanFreq, times=nsim)
    pValues <- freqDecisionAtN <- allFreqDecisions <- vector("integer", nsim)
  }

  if (is.null(n2Plan) || paired) {
    sampleSizeRatio <- 1
  } else {
    sampleSizeRatio <- n2Plan/n1Plan
  }

  someData <- generateTTestData("n1Plan"=n1Plan, "n2Plan"=n2Plan, "nsim"=nsim, "deltaTrue"=deltaTrue,
                                "muGlobal"=muGlobal, "sigmaTrue"=sigmaTrue, "paired"=paired, "seed"=seed)

  dataGroup1 <- someData[["dataGroup1"]]
  dataGroup2 <- someData[["dataGroup2"]]

  if (safeOptioStop) {
    n1Samples <- seq.int(lowN, n1Plan)

    if (is.null(n2Plan)) {
      n2Samples <- NULL
    } else {
      n2Samples <- ceiling(sampleSizeRatio*n1Samples)
    }

    if (pb)
      pbSafe <- utils::txtProgressBar(style=1, title="Safe optional stopping")

    for (iter in seq.int(nsim)) {
      subData1 <- dataGroup1[iter, ]
      subData2 <- dataGroup2[iter, ]

      someT <- unname(stats::t.test("x"=subData1, "y"=subData2, "alternative"=alternative,
                                    "var.equal"=TRUE, "paired"=paired)[["statistic"]])
      someS <- safeZTestStat("t"=someT, "deltaS"=deltaS, "n1"=n1Plan, "n2"=n2Plan, "alternative"=alternative,
                             "paired"=paired)

      sValues[iter] <- someS

      if (someS >= 1/alpha)
        safeDecisionAtN[iter] <- 1

      for (k in seq_along(n1Samples)) {

        # TODO(Alexander): Perhaps replace by custom t computing to speed things up
        #
        someT <- unname(stats::t.test("x"=subData1[seq.int(n1Samples[k])], "y"=subData2[seq.int(n2Samples[k])],
                                      "alternative"=alternative, "var.equal"=TRUE, "paired"=paired)[["statistic"]])

        someS <- safeZTestStat("n1"=n1Samples[k], "n2"=n2Samples[k], "t"=someT, "deltaS"=deltaS,
                               "alternative"=alternative, "paired"=paired)

        if (someS >= 1/alpha) {
          allSafeN[iter] <- n1Samples[k]
          allSafeDecisions[iter] <- 1

          sValues[iter] <- someS
          break()
        }
      } # End loop lowN to n1Plan

      if (pb)
        utils::setTxtProgressBar(pbSafe, value=iter/nsim, title="Experiments")

    } # End iterations

    if (pb)
      close(pbSafe)

    safeSim <- list(powerOptioStop=mean(allSafeDecisions),
                    powerAtN1Plan=mean(safeDecisionAtN),
                    nMean=mean(allSafeN),
                    probLessNDesign=mean(allSafeN < n1Plan),
                    lowN=min(allSafeN), sValues=sValues
    )

    safeSim[["allN"]] <- allSafeN
    safeSim[["allSafeDecisions"]] <- allSafeDecisions
    safeSim[["allRejectedN"]] <- allSafeN[-which(allSafeN*allSafeDecisions==0)]

    if (!is.null(n1PlanFreq))
      safeSim[["probLeqN1PlanFreq"]] <- mean(allSafeN <= n1PlanFreq)

    if (isTRUE(logging)) {
      safeSim[["dataGroup1"]] <- dataGroup1
      safeSim[["dataGroup2"]] <- dataGroup2
    }

    result[["safeSim"]] <- safeSim
  }

  if (freqOptioStop) {
    # Note(Alexander): Adjust data set
    #
    if (is.null(n2Plan)) {
      sampleSizeRatio <- 1

      if (n1PlanFreq < n1Plan) {
        dataGroup1 <- dataGroup1[, seq.int(n1PlanFreq)]
      }

      if (n1PlanFreq > n1Plan) {
        n1Diff <- n1PlanFreq - n1Plan

        someData <- generateTTestData("n1Plan"=n1Diff, "n2Plan"=n2Plan, "nsim"=nsim, "deltaTrue"=deltaTrue,
                                      "muGlobal"=muGlobal, "sigmaTrue"=sigmaTrue, "paired"=paired, "seed"=seed+1)
        dataGroup1 <- cbind(dataGroup1, someData[["dataGroup1"]])
      }
    } else {
      # Note(Alexander): Two-sample case

      if (paired) {
        sampleSizeRatio <- 1
      } else {
        sampleSizeRatio <- n2PlanFreq/n1PlanFreq
      }

      if (n1PlanFreq < n1Plan) {
        dataGroup1 <- dataGroup1[, seq.int(n1PlanFreq)]
      } else if (n1PlanFreq > n1Plan) {
        n1Diff <- n1PlanFreq - n1Plan

        someData <- generateTTestData("n1Plan"=n1Diff, "n2Plan"=n2Plan, "nsim"=nsim, "deltaTrue"=deltaTrue,
                                      "muGlobal"=muGlobal, "sigmaTrue"=sigmaTrue, "paired"=paired, "seed"=seed+1)
        dataGroup1 <- cbind(dataGroup1, someData[["dataGroup1"]])
      }

      if (n2PlanFreq < n2Plan) {
        dataGroup2 <- dataGroup2[, seq.int(n2PlanFreq)]
      } else if (n2PlanFreq > n2Plan) {
        n2Diff <- n2PlanFreq - n2Plan

        someData <- generateTTestData("n1Plan"=1, "n2Plan"=n2Diff, "nsim"=nsim, "deltaTrue"=deltaTrue,
                                      "muGlobal"=muGlobal, "sigmaTrue"=sigmaTrue, "paired"=paired, "seed"=seed+1)
        dataGroup2 <- cbind(dataGroup2, someData[["dataGroup2"]])
      }
    }

    n1Samples <- seq.int(lowN, n1PlanFreq)

    if (is.null(n2PlanFreq)) {
      n2Samples <- NULL
    } else {
      n2Samples <- ceiling(sampleSizeRatio*n1Samples)
    }

    if (pb)
      pbFreq <- utils::txtProgressBar(style=1, title="Frequentist optional stopping")

    for (iter in seq.int(nsim)) {
      subData1 <- dataGroup1[iter, ]
      subData2 <- dataGroup2[iter, ]
      someP <- stats::t.test("x"=subData1, "y"=subData2, "alternative"=alternative,
                             "var.equal"=TRUE, "paired"=paired)[["p.value"]]

      pValues[iter] <- someP

      if (someP < alpha)
        freqDecisionAtN[iter] <- 1

      for (k in seq_along(n1Samples)) {
        someP <- stats::t.test("x"=subData1[seq.int(n1Samples[k])], "y"=subData2[seq.int(n2Samples[k])],
                               "alternative"=alternative, "var.equal"=TRUE, "paired"=paired)[["p.value"]]

        if (someP < alpha) {
          allFreqN[iter] <- n1Samples[k]
          allFreqDecisions[iter] <- 1
          pValues[iter] <- someP
          break()
        }
      } # End loop lowN to n1Plan

      if (pb)
        utils::setTxtProgressBar(pbFreq, value=iter/nsim, title="Experiments")
    } # End iterations

    if (pb)
      close(pbFreq)

    freqSim <- list(powerOptioStop=mean(allFreqDecisions),
                    powerAtN1Plan=mean(freqDecisionAtN),
                    nMean=mean(allFreqN),
                    allFreqDecisions=allFreqDecisions,
                    probLessNDesign=mean(allFreqN < n1PlanFreq),
                    lowN=min(allFreqN), pValues=pValues
    )

    freqSim[["allN"]] <- allFreqN

    if (safeOptioStop)
      freqSim[["probLeqNSafe"]] <- mean(allFreqN <= n1Plan)

    if (isTRUE(logging)) {
      freqSim[["dataGroup1"]] <- dataGroup1
      freqSim[["dataGroup2"]] <- dataGroup2
    }

    result[["freqSim"]] <- freqSim
  }
  return(result)
}
Generates normal data depending on the design: "oneSampleT", "pairedSampleT", "twoSampleT"

generateTTestData(20, 15)
}
